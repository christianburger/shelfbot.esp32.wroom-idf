#include "http_server.hpp"

static const char *TAG = "http_server";

static httpd_handle_t server = NULL;

// Extern declarations for the embedded HTML file.
// These symbols are generated by the build system.
extern const uint8_t index_html_start[] asm("_binary_index_html_start");
extern const uint8_t index_html_end[]   asm("_binary_index_html_end");

// Handler for the root URL (/)
static esp_err_t root_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Serving root page from embedded file");

    // Send the embedded index.html file
    httpd_resp_set_type(req, "text/html");
    httpd_resp_send(req, (const char *)index_html_start, index_html_end - index_html_start);

    return ESP_OK;
}


// Handler for /status
static esp_err_t status_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *motors = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "motors", motors);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON *motor = cJSON_CreateObject();
        cJSON_AddNumberToObject(motor, "index", i);
        cJSON_AddNumberToObject(motor, "position", motor_control_get_motor_position_double(i));
        cJSON_AddNumberToObject(motor, "velocity", motor_control_get_motor_velocity_double(i));
        cJSON_AddBoolToObject(motor, "running", motor_control_is_motor_running(i));
        cJSON_AddItemToArray(motors, motor);
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for /motor_positions
static esp_err_t motor_positions_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *positions = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "positions", positions);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON_AddItemToArray(positions, cJSON_CreateNumber(motor_control_get_motor_position_double(i)));
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for /motor_velocities
static esp_err_t motor_velocities_handler(httpd_req_t *req) {
    cJSON *root = cJSON_CreateObject();
    cJSON *velocities = cJSON_CreateArray();
    cJSON_AddItemToObject(root, "velocities", velocities);

    for (int i = 0; i < NUM_MOTORS; i++) {
        cJSON_AddItemToArray(velocities, cJSON_CreateNumber(motor_control_get_motor_velocity_double(i)));
    }

    const char *json_string = cJSON_Print(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_string, HTTPD_RESP_USE_STRLEN);
    cJSON_Delete(root);
    free((void*)json_string);
    return ESP_OK;
}

// Handler for POST /motor
static esp_err_t motor_move_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received POST request on /motor");
    char buf[128];
    int ret, remaining = req->content_len;
    
    if (remaining > sizeof(buf) - 1) {
        ESP_LOGE(TAG, "Request too long");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Request too long");
        return ESP_FAIL;
    }
    ret = httpd_req_recv(req, buf, remaining);
    if (ret <= 0) { 
        ESP_LOGE(TAG, "Failed to receive request");
        return ESP_FAIL; 
    }
    buf[ret] = '\0';
    ESP_LOGI(TAG, "Request payload: %s", buf);

    cJSON *root = cJSON_Parse(buf);
    if (!root) {
        ESP_LOGE(TAG, "Invalid JSON");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    const cJSON *motor_json = cJSON_GetObjectItem(root, "motor");
    const cJSON *position_json = cJSON_GetObjectItem(root, "position");

    if (cJSON_IsNumber(motor_json) && cJSON_IsNumber(position_json)) {
        int motor_index = motor_json->valueint;
        double position = position_json->valuedouble;
        ESP_LOGI(TAG, "Calling motor_control_set_motor_position_double(%d, %f)", motor_index, position);
        motor_control_set_motor_position_double(motor_index, position);
    } else {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing or invalid motor/position");
        cJSON_Delete(root);
        return ESP_FAIL;
    }

    cJSON_Delete(root);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}

// Handler for POST /motors
static esp_err_t all_motors_move_handler(httpd_req_t *req) {
    ESP_LOGI(TAG, "Received POST request on /motors");
    char buf[512];
    int ret, remaining = req->content_len;

    if (remaining > sizeof(buf) - 1) {
        ESP_LOGE(TAG, "Request too long");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Request too long");
        return ESP_FAIL;
    }
    ret = httpd_req_recv(req, buf, remaining);
    if (ret <= 0) { 
        ESP_LOGE(TAG, "Failed to receive request");
        return ESP_FAIL; 
    }
    buf[ret] = '\0';
    ESP_LOGI(TAG, "Request payload: %s", buf);

    cJSON *root = cJSON_Parse(buf);
    if (!root) {
        ESP_LOGE(TAG, "Invalid JSON");
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }

    cJSON *positions_json = cJSON_GetObjectItem(root, "positions");
    long speed = cJSON_GetObjectItem(root, "speed")->valueint;
    bool nonBlocking = cJSON_GetObjectItem(root, "nonBlocking")->valueint;
    ESP_LOGI(TAG, "Parsed speed: %ld, nonBlocking: %s", speed, nonBlocking ? "true" : "false");

    double positions[NUM_MOTORS];
    int num_positions = cJSON_GetArraySize(positions_json);
    if (num_positions > NUM_MOTORS) {
        num_positions = NUM_MOTORS; // Prevent buffer overflow
    }

    for (int i = 0; i < num_positions; i++) {
        positions[i] = cJSON_GetArrayItem(positions_json, i)->valuedouble;
        ESP_LOGI(TAG, "Parsed position[%d]: %f", i, positions[i]);
    }

    ESP_LOGI(TAG, "Calling motor_control_move_all_motors_vector(...)");
    motor_control_move_all_motors_vector(positions, num_positions, speed, nonBlocking);

    cJSON_Delete(root);
    httpd_resp_send(req, "OK", HTTPD_RESP_USE_STRLEN);
    return ESP_OK;
}


void start_webserver(void) {
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.lru_purge_enable = true;
    config.stack_size = 8192;

    ESP_LOGI(TAG, "Starting server on port: '%d'", config.server_port);
    if (httpd_start(&server, &config) == ESP_OK) {
        // Registering URI handlers
        httpd_uri_t root_uri = { .uri = "/", .method = HTTP_GET, .handler = root_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &root_uri);

        httpd_uri_t status_uri = { .uri = "/status", .method = HTTP_GET, .handler = status_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &status_uri);

        httpd_uri_t motor_pos_uri = { .uri = "/motor_positions", .method = HTTP_GET, .handler = motor_positions_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_pos_uri);

        httpd_uri_t motor_vel_uri = { .uri = "/motor_velocities", .method = HTTP_GET, .handler = motor_velocities_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_vel_uri);

        httpd_uri_t motor_move_uri = { .uri = "/motor", .method = HTTP_POST, .handler = motor_move_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &motor_move_uri);

        httpd_uri_t all_motors_move_uri = { .uri = "/motors", .method = HTTP_POST, .handler = all_motors_move_handler, .user_ctx = NULL };
        httpd_register_uri_handler(server, &all_motors_move_uri);

        return;
    }
    ESP_LOGI(TAG, "Error starting server!");
}

void stop_webserver(void) {
    if (server) {
        httpd_stop(server);
        server = NULL;
    }
}
